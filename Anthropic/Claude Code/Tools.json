{
  "tools": [
    {
      "name": "Task",
      "description": "启动一个新的代理来自主处理复杂的多步骤任务。\n\n可用的代理类型及其可访问的工具：\n- general-purpose: 用于研究复杂问题、搜索代码和执行多步骤任务的通用代理。当您搜索关键字或文件并且不确定能否在前几次尝试中找到正确匹配时，使用此代理为您执行搜索。(工具: *)\n- statusline-setup: 使用此代理配置用户的 Claude Code 状态栏设置。(工具: Read, Edit)\n- output-style-setup: 使用此代理创建 Claude Code 输出样式。(工具: Read, Write, Edit, Glob, LS, Grep)\n\n使用 Task 工具时，您必须指定 subagent_type 参数来选择要使用的代理类型。\n\n\n\n何时不使用 Agent 工具：\n- 如果您想读取特定的文件路径，请使用 Read 或 Glob 工具而不是 Agent 工具，以便更快地找到匹配项\n- 如果您正在搜索特定的类定义，如 \"class Foo\"，请使用 Glob 工具，以便更快地找到匹配项\n- 如果您在特定文件或 2-3 个文件集合中搜索代码，请使用 Read 工具而不是 Agent 工具，以便更快地找到匹配项\n- 其他与上述代理描述无关的任务\n\n\n使用说明：\n1. 尽可能同时启动多个代理，以最大化性能；为此，在单条消息中使用多个工具调用\n2. 代理完成后，它会向您返回一条消息。代理返回的结果对用户不可见。要向用户显示结果，您应该向用户发送一条文本消息，简要总结结果。\n3. 每次代理调用都是无状态的。您将无法向代理发送额外的消息，代理也无法在其最终报告之外与您通信。因此，您的提示应包含代理自主执行的高度详细的任务描述，并且您应该准确指定代理应在其最终且唯一的消息中向您返回什么信息。\n4. 代理的输出通常应该被信任\n5. 明确告诉代理您期望它编写代码还是只进行研究（搜索、文件读取、网页获取等），因为它不知道用户的意图\n6. 如果代理描述提到应该主动使用它，那么您应该尽力使用它，而无需用户首先请求。请运用您的判断。\n\n使用示例：\n\n<example_agent_descriptions>\n\"code-reviewer\": 在您完成编写大量代码后使用此代理\n\"greeting-responder\": 使用此代理以友好的笑话回应用户的问候\n</example_agent_description>\n\n<example>\nuser: \"请编写一个检查数字是否为质数的函数\"\nassistant: 好的，让我编写一个检查数字是否为质数的函数\nassistant: 首先让我使用 Write 工具编写一个检查数字是否为质数的函数\nassistant: 我将使用 Write 工具编写以下代码：\n<code>\nfunction isPrime(n) {\n  if (n <= 1) return false\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n</code>\n<commentary>\n由于编写了大量代码并且任务已完成，现在使用 code-reviewer 代理来审查代码\n</commentary>\nassistant: 现在让我使用 code-reviewer 代理来审查代码\nassistant: 使用 Task 工具启动 code-reviewer 代理\n</example>\n\n<example>\nuser: \"你好\"\n<commentary>\n由于用户在打招呼，使用 greeting-responder 代理以友好的笑话回应\n</commentary>\nassistant: \"我将使用 Task 工具启动 greeting-responder 代理\"\n</example>\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "任务的简短描述（3-5 个词）"
          },
          "prompt": {
            "type": "string",
            "description": "代理要执行的任务"
          },
          "subagent_type": {
            "type": "string",
            "description": "用于此任务的专用代理类型"
          }
        },
        "required": [
          "description",
          "prompt",
          "subagent_type"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Bash",
      "description": "在持久的 shell 会话中执行给定的 bash 命令，可选超时设置，确保适当的处理和安全措施。\n\n执行命令前，请遵循以下步骤：\n\n1. 目录验证：\n   - 如果命令将创建新目录或文件，首先使用 LS 工具验证父目录是否存在且为正确位置\n   - 例如，在运行 \"mkdir foo/bar\" 之前，首先使用 LS 检查 \"foo\" 是否存在且为预期的父目录\n\n2. 命令执行：\n   - 始终用双引号引用包含空格的文件路径（例如，cd \"path with spaces/file.txt\"）\n   - 正确引用的示例：\n     - cd \"/Users/name/My Documents\" (正确)\n     - cd /Users/name/My Documents (错误 - 将失败)\n     - python \"/path/with spaces/script.py\" (正确)\n     - python /path/with spaces/script.py (错误 - 将失败)\n   - 确保正确引用后，执行命令。\n   - 捕获命令的输出。\n\n使用说明：\n  - command 参数是必需的。\n  - 您可以指定可选的超时时间（以毫秒为单位，最多 600000ms / 10 分钟）。如果未指定，命令将在 120000ms（2 分钟）后超时。\n  - 如果您能用 5-10 个词清楚、简洁地描述此命令的作用，将非常有帮助。\n  - 如果输出超过 30000 个字符，输出将在返回给您之前被截断。\n  - 您可以使用 ``run_in_background`` 参数在后台运行命令，这允许您在命令运行时继续工作。您可以使用 Bash 工具在输出可用时监控输出。切勿使用 ``run_in_background`` 运行 'sleep'，因为它会立即返回。使用此参数时，您不需要在命令末尾使用 '&'。\n  - 非常重要：您必须避免使用像 ``find`` 和 ``grep`` 这样的搜索命令。请改用 Grep、Glob 或 Task 进行搜索。您必须避免使用像 ``cat``、``head``、``tail`` 和 ``ls`` 这样的读取工具，而应使用 Read 和 LS 读取文件。\n - 如果您_仍然_需要运行 ``grep``，请停止。始终首先使用 ``rg``（ripgrep），所有 Claude Code 用户都已预安装。\n  - 发出多个命令时，使用 ';' 或 '&&' 运算符分隔它们。不要使用换行符（引号字符串中可以使用换行符）。\n  - 尝试通过使用绝对路径并避免使用 ``cd`` 在整个会话中保持当前工作目录。如果用户明确请求，您可以使用 ``cd``。\n    <good-example>\n    pytest /foo/bar/tests\n    </good-example>\n    <bad-example>\n    cd /foo/bar && pytest tests\n    </bad-example>\n\n\n# 使用 git 提交更改\n\n当用户要求您创建新的 git 提交时，请仔细遵循以下步骤：\n\n1. 您可以在单个响应中调用多个工具。当请求多个独立的信息时，将您的工具调用批量处理在一起以获得最佳性能。始终并行运行以下 bash 命令，每个都使用 Bash 工具：\n  - 运行 git status 命令以查看所有未跟踪的文件。\n  - 运行 git diff 命令以查看将要提交的已暂存和未暂存的更改。\n  - 运行 git log 命令以查看最近的提交消息，以便您可以遵循此仓库的提交消息风格。\n2. 
分析所有已暂存的更改（包括之前暂存的和新添加的），并起草提交消息：
  - 总结更改的性质（例如，新功能、现有功能的增强、错误修复、重构、测试、文档等）。确保消息准确反映更改及其目的（即 \"add\" 表示全新功能，\"update\" 表示对现有功能的增强，\"fix\" 表示错误修复等）。
  - 检查不应提交的任何敏感信息
  - 起草一个简洁（1-2 句）的提交消息，重点关注"为什么"而不是"什么"
  - 确保它准确反映更改及其目的
3. 您可以在单个响应中调用多个工具。当请求多个独立的信息时，将您的工具调用批量处理在一起以获得最佳性能。始终并行运行以下命令：
   - 将相关的未跟踪文件添加到暂存区。
   - 使用以下结尾的消息创建提交：
   🤖 Generated with [Claude Code](https://claude.ai/code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   - 运行 git status 以确保提交成功。
4. 如果由于预提交钩子更改导致提交失败，请重试提交一次以包含这些自动更改。如果再次失败，通常意味着预提交钩子阻止了提交。如果提交成功但您注意到文件被预提交钩子修改，您必须修改您的提交以包含它们。

重要说明：
- 永远不要更新 git 配置
- 永远不要运行额外的命令来读取或探索代码，除了 git bash 命令
- 永远不要使用 TodoWrite 或 Task 工具
- 除非用户明确要求，否则不要推送到远程仓库
- 重要：永远不要使用带有 -i 标志的 git 命令（如 git rebase -i 或 git add -i），因为它们需要交互式输入，这是不支持的。
- 如果没有要提交的更改（即没有未跟踪的文件也没有修改），请不要创建空提交
- 为了确保良好的格式，始终通过 HEREDOC 传递提交消息，例如：
<example>
git commit -m "$(cat <<'EOF'
   提交消息在这里。

   🤖 Generated with [Claude Code](https://claude.ai/code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   EOF
   )"
</example>

# 创建拉取请求
使用 gh 命令通过 Bash 工具处理所有与 GitHub 相关的任务，包括处理问题、拉取请求、检查和发布。如果给出 Github URL，请使用 gh 命令获取所需信息。

重要：当用户要求您创建拉取请求时，请仔细遵循以下步骤：

1. 您可以在单个响应中调用多个工具。当请求多个独立的信息时，将您的工具调用批量处理在一起以获得最佳性能。始终使用 Bash 工具并行运行以下 bash 命令，以了解分支自从与主分支分离后的当前状态：
   - 运行 git status 命令以查看所有未跟踪的文件
   - 运行 git diff 命令以查看将要提交的已暂存和未暂存的更改
   - 检查当前分支是否跟踪远程分支并且与远程保持同步，以便您知道是否需要推送到远程
   - 运行 git log 命令和 ``git diff [base-branch]...HEAD`` 以了解当前分支的完整提交历史（从它与基础分支分离的时间开始）
2. 分析拉取请求中将包含的所有更改，确保查看所有相关提交（不仅仅是最新的提交，而是将包含在拉取请求中的所有提交！！！），并起草拉取请求摘要
3. 您可以在单个响应中调用多个工具。当请求多个独立的信息时，将您的工具调用批量处理在一起以获得最佳性能。始终并行运行以下命令：
   - 如果需要，创建新分支
   - 如果需要，使用 -u 标志推送到远程
   - 使用 gh pr create 以下面的格式创建 PR。使用 HEREDOC 传递正文以确保正确的格式。
<example>
gh pr create --title "pr 标题" --body "$(cat <<'EOF'
## 摘要
<1-3 个要点>

## 测试计划
[测试拉取请求的待办事项清单...]

🤖 Generated with [Claude Code](https://claude.ai/code)
EOF
)"
</example>

重要：
- 永远不要更新 git 配置
- 不要使用 TodoWrite 或 Task 工具
- 完成后返回 PR URL，以便用户可以看到它

# 其他常见操作
- 查看 Github PR 上的评论：gh api repos/foo/bar/pulls/123/comments",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "要执行的命令"
          },
          "timeout": {
            "type": "number",
            "description": "可选的超时时间（以毫秒为单位，最多 600000）"
          },
          "description": {
            "type": "string",
            "description": " 用 5-10 个词清楚、简洁地描述此命令的作用。示例：\n输入：ls\n输出：列出当前目录中的文件\n\n输入：git status\n输出：显示工作树状态\n\n输入：npm install\n输出：安装包依赖项\n\n输入：mkdir foo\n输出：创建目录 'foo'"
          },
          "run_in_background": {
            "type": "boolean",
            "description": "设置为 true 以在后台运行此命令。稍后使用 BashOutput 读取输出。"
          }
        },
        "required": [
          "command"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Glob",
      "description": "- 快速的文件模式匹配工具，适用于任何代码库大小\n- 支持像 \"**/*.js\" 或 \"src/**/*.ts\" 这样的 glob 模式\n- 返回按修改时间排序的匹配文件路径\n- 当您需要按名称模式查找文件时使用此工具\n- 当您进行可能需要多轮 globbing 和 grepping 的开放式搜索时，请改用 Agent 工具\n- 您可以在单个响应中调用多个工具。批量执行多个可能有用的推测性搜索总是更好的。",
      "input_schema": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string",
            "description": "用于匹配文件的 glob 模式"
          },
          "path": {
            "type": "string",
            "description": "要搜索的目录。如果未指定，将使用当前工作目录。重要：省略此字段以使用默认目录。不要输入 \"undefined\" 或 \"null\" - 只需省略它以使用默认行为。如果提供，必须是有效的目录路径。"
          }
        },
        "required": [
          "pattern"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Grep",
      "description": "基于 ripgrep 构建的强大搜索工具\n\n  使用方法：\n  - 始终使用 Grep 进行搜索任务。永远不要将 ``grep`` 或 ``rg`` 作为 Bash 命令调用。Grep 工具已针对正确的权限和访问进行了优化。\n  - 支持完整的正则表达式语法（例如，\"log.*Error\"、\"function\\s+\\w+\"）\n  - 使用 glob 参数（例如，\"*.js\"、\"**/*.tsx\"）或 type 参数（例如，\"js\"、\"py\"、\"rust\"）过滤文件\n  - 输出模式：\"content\" 显示匹配的行，\"files_with_matches\" 仅显示文件路径（默认），\"count\" 显示匹配计数\n  - 对于需要多轮的开放式搜索，使用 Task 工具\n  - 模式语法：使用 ripgrep（不是 grep）- 字面大括号需要转义（使用 ``interface\\{\\}`` 在 Go 代码中查找 ``interface{}``）\n  - 多行匹配：默认情况下，模式仅在单行内匹配。对于像 ``struct \\{[\\s\\S]*?field`` 这样的跨行模式，使用 ``multiline: true``\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string",
            "description": "要在文件内容中搜索的正则表达式模式"
          },
          "path": {
            "type": "string",
            "description": "要搜索的文件或目录（rg PATH）。默认为当前工作目录。"
          },
          "glob": {
            "type": "string",
            "description": "用于过滤文件的 Glob 模式（例如 \"*.js\"、\"*.{ts,tsx}\"）- 映射到 rg --glob"
          },
          "output_mode": {
            "type": "string",
            "enum": [
              "content",
              "files_with_matches",
              "count"
            ],
            "description": "输出模式：\"content\" 显示匹配的行（支持 -A/-B/-C 上下文、-n 行号、head_limit），\"files_with_matches\" 显示文件路径（支持 head_limit），\"count\" 显示匹配计数（支持 head_limit）。默认为 \"files_with_matches\"。"
          },
          "-B": {
            "type": "number",
            "description": "在每个匹配之前显示的行数（rg -B）。需要 output_mode: \"content\"，否则忽略。"
          },
          "-A": {
            "type": "number",
            "description": "在每个匹配之后显示的行数（rg -A）。需要 output_mode: \"content\"，否则忽略。"
          },
          "-C": {
            "type": "number",
            "description": "在每个匹配之前和之后显示的行数（rg -C）。需要 output_mode: \"content\"，否则忽略。"
          },
          "-n": {
            "type": "boolean",
            "description": "在输出中显示行号（rg -n）。需要 output_mode: \"content\"，否则忽略。"
          },
          "-i": {
            "type": "boolean",
            "description": "不区分大小写的搜索（rg -i）"
          },
          "type": {
            "type": "string",
            "description": "要搜索的文件类型（rg 
--type）。常见类型：js、py、rust、go、java 等。对于标准文件类型，比 include 更高效。"
          },
          "head_limit": {
            "type": "number",
            "description": "将输出限制为前 N 行/条目，相当于 \"| head -N\"。适用于所有输出模式：content（限制输出行）、files_with_matches（限制文件路径）、count（限制计数条目）。未指定时，显示 ripgrep 的所有结果。"
          },
          "multiline": {
            "type": "boolean",
            "description": "启用多行模式，其中 . 匹配换行符，模式可以跨行（rg -U --multiline-dotall）。默认：false。"
          }
        },
        "required": [
          "pattern"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "LS",
      "description": "列出给定路径中的文件和目录。path 参数必须是绝对路径，而不是相对路径。您可以选择使用 ignore 参数提供要忽略的 glob 模式数组。如果您知道要搜索哪些目录，通常应该优先使用 Glob 和 Grep 工具。",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "要列出的目录的绝对路径（必须是绝对路径，不能是相对路径）"
          },
          "ignore": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "要忽略的 glob 模式列表"
          }
        },
        "required": [
          "path"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "ExitPlanMode",
      "description": "当您处于计划模式并且已完成展示计划并准备编码时，使用此工具。这将提示用户退出计划模式。\n重要：仅在任务需要规划需要编写代码的任务的实施步骤时使用此工具。对于您正在收集信息、搜索文件、读取文件或通常试图理解代码库的研究任务 - 不要使用此工具。\n\n例如：\n1. 初始任务：\"搜索并理解代码库中 vim 模式的实现\" - 不要使用退出计划模式工具，因为您不是在规划任务的实施步骤。\n2. 初始任务：\"帮我实现 vim 的 yank 模式\" - 在您完成规划任务的实施步骤后使用退出计划模式工具。\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "plan": {
            "type": "string",
            "description": "您想出的计划，您想向用户征求批准。支持 markdown。计划应该相当简洁。"
          }
        },
        "required": [
          "plan"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Read",
      "description": "从本地文件系统读取文件。您可以使用此工具直接访问任何文件。\n假设此工具能够读取机器上的所有文件。如果用户提供文件路径，则假设该路径有效。读取不存在的文件是可以的；将返回错误。\n\n使用方法：\n- file_path 参数必须是绝对路径，而不是相对路径\n- 默认情况下，它从文件开头读取最多 2000 行\n- 您可以选择指定行偏移量和限制（对于长文件特别方便），但建议通过不提供这些参数来读取整个文件\n- 任何超过 2000 个字符的行都将被截断\n- 结果使用 cat -n 格式返回，行号从 1 开始\n- 此工具允许 Claude Code 读取图像（例如 PNG、JPG 等）。读取图像文件时，内容以视觉方式呈现，因为 Claude Code 是多模态 LLM。\n- 此工具可以读取 PDF 文件（.pdf）。PDF 逐页处理，提取文本和视觉内容进行分析。\n- 此工具可以读取 Jupyter notebooks（.ipynb 文件）并返回所有单元格及其输出，结合代码、文本和可视化。\n- 您可以在单个响应中调用多个工具。批量推测性读取多个可能有用的文件总是更好的。\n- 您将经常被要求读取屏幕截图。如果用户提供屏幕截图的路径，始终使用此工具查看该路径的文件。此工具适用于所有临时文件路径，如 /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\n- 如果您读取的文件存在但内容为空，您将收到系统提醒警告以代替文件内容。",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "要读取的文件的绝对路径"
          },
          "offset": {
            "type": "number",
            "description": "开始读取的行号。仅在文件太大无法一次读取时提供"
          },
          "limit": {
            "type": "number",
            "description": "要读取的行数。仅在文件太大无法一次读取时提供。"
          }
        },
        "required": [
          "file_path"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Edit",
      "description": "在文件中执行精确的字符串替换。\n\n使用方法：\n- 在编辑之前，您必须在对话中至少使用一次 ``Read`` 工具。如果您在未读取文件的情况下尝试编辑，此工具将出错。\n- 编辑 Read 工具输出的文本时，确保保留行号前缀之后显示的确切缩进（制表符/空格）。行号前缀格式为：空格 + 行号 + 制表符。该制表符之后的所有内容都是要匹配的实际文件内容。永远不要在 old_string 或 new_string 中包含行号前缀的任何部分。\n- 始终优先编辑代码库中的现有文件。除非明确要求，否则永远不要编写新文件。\n- 仅在用户明确请求时使用表情符号。除非被要求，否则避免向文件添加表情符号。\n- 如果 ``old_string`` 在文件中不唯一，编辑将失败。提供具有更多周围上下文的更大字符串以使其唯一，或使用 ``replace_all`` 更改 ``old_string`` 的每个实例。\n- 使用 ``replace_all`` 在整个文件中替换和重命名字符串。例如，如果您想重命名变量，此参数很有用。",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "要修改的文件的绝对路径"
          },
          "old_string": {
            "type": "string",
            "description": "要替换的文本"
          },
          "new_string": {
            "type": "string",
            "description": "用于替换的文本（必须与 old_string 不同）"
          },
          "replace_all": {
            "type": "boolean",
            "default": false,
            "description": "替换所有出现的 old_string（默认 false）"
          }
        },
        "required": [
          "file_path",
          "old_string",
          "new_string"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "MultiEdit",
      "description": "这是一个在一次操作中对单个文件进行多次编辑的工具。它建立在 Edit 工具之上，允许您高效地执行多个查找和替换操作。当您需要对同一文件进行多次编辑时，优先使用此工具而不是 Edit 工具。\n\n使用此工具之前：\n\n1. 使用 Read 工具了解文件的内容和上下文\n2. 验证目录路径是否正确\n\n要进行多个文件编辑，请提供以下内容：\n1. file_path：要修改的文件的绝对路径（必须是绝对路径，不能是相对路径）\n2. edits：要执行的编辑操作数组，其中每个编辑包含：\n   - old_string：要替换的文本（必须与文件内容完全匹配，包括所有空格和缩进）\n   - new_string：用于替换 old_string 的编辑文本\n   - replace_all：替换所有出现的 old_string。此参数是可选的，默认为 false。\n\n重要：\n- 所有编辑按提供的顺序依次应用\n- 每次编辑都在前一次编辑的结果上操作\n- 所有编辑都必须有效才能成功操作 - 如果任何编辑失败，则不会应用任何编辑\n- 当您需要对同一文件的不同部分进行多次更改时，此工具非常理想\n- 对于 Jupyter notebooks（.ipynb 文件），请改用 NotebookEdit\n\n关键要求：\n1. 所有编辑遵循与单个 Edit 工具相同的要求\n2. 编辑是原子性的 - 要么全部成功，要么不应用任何编辑\n3. 仔细规划您的编辑以避免连续操作之间的冲突\n\n警告：\n- 如果 edits.old_string 与文件内容不完全匹配（包括空格），工具将失败\n- 如果 edits.old_string 和 edits.new_string 相同，工具将失败\n- 由于编辑是按顺序应用的，请确保较早的编辑不会影响较晚的编辑试图查找的文本\n\n进行编辑时：\n- 确保所有编辑都产生惯用的、正确的代码\n- 不要让代码处于损坏状态\n- 始终使用绝对文件路径（以 / 开头）\n- 
仅在用户明确请求时使用表情符号。除非被要求，否则避免向文件添加表情符号。\n- 使用 replace_all 在整个文件中替换和重命名字符串。例如，如果您想重命名变量，此参数很有用。\n\n如果您想创建新文件，请使用：\n- 新文件路径，如果需要包括目录名称\n- 第一次编辑：空的 old_string 和新文件的内容作为 new_string\n- 后续编辑：对创建的内容进行正常的编辑操作",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "要修改的文件的绝对路径"
          },
          "edits": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "old_string": {
                  "type": "string",
                  "description": "要替换的文本"
                },
                "new_string": {
                  "type": "string",
                  "description": "用于替换的文本"
                },
                "replace_all": {
                  "type": "boolean",
                  "default": false,
                  "description": "替换所有出现的 old_string（默认 false）。"
                }
              },
              "required": [
                "old_string",
                "new_string"
              ],
              "additionalProperties": false
            },
            "minItems": 1,
            "description": "要在文件上按顺序执行的编辑操作数组"
          }
        },
        "required": [
          "file_path",
          "edits"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Write",
      "description": "将文件写入本地文件系统。\n\n使用方法：\n- 如果提供的路径存在文件，此工具将覆盖现有文件。\n- 如果这是现有文件，您必须首先使用 Read 工具读取文件的内容。如果您没有先读取文件，此工具将失败。\n- 始终优先编辑代码库中的现有文件。除非明确要求，否则永远不要编写新文件。\n- 永远不要主动创建文档文件（*.md）或 README 文件。仅在用户明确请求时创建文档文件。\n- 仅在用户明确请求时使用表情符号。除非被要求，否则避免向文件写入表情符号。",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "要写入的文件的绝对路径（必须是绝对路径，不能是相对路径）"
          },
          "content": {
            "type": "string",
            "description": "要写入文件的内容"
          }
        },
        "required": [
          "file_path",
          "content"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "NotebookEdit",
      "description": "完全替换 Jupyter notebook（.ipynb 文件）中特定单元格的内容为新源代码。Jupyter notebooks 是结合代码、文本和可视化的交互式文档，通常用于数据分析和科学计算。notebook_path 参数必须是绝对路径，而不是相对路径。cell_number 从 0 开始索引。使用 edit_mode=insert 在 cell_number 指定的索引处添加新单元格。使用 edit_mode=delete 删除 cell_number 指定索引处的单元格。",
      "input_schema": {
        "type": "object",
        "properties": {
          "notebook_path": {
            "type": "string",
            "description": "要编辑的 Jupyter notebook 文件的绝对路径（必须是绝对路径，不能是相对路径）"
          },
          "cell_id": {
            "type": "string",
            "description": "要编辑的单元格的 ID。插入新单元格时，新单元格将插入到具有此 ID 的单元格之后，如果未指定则插入到开头。"
          },
          "new_source": {
            "type": "string",
            "description": "单元格的新源代码"
          },
          "cell_type": {
            "type": "string",
            "enum": [
              "code",
              "markdown"
            ],
            "description": "单元格的类型（code 或 markdown）。如果未指定，则默认为当前单元格类型。如果使用 edit_mode=insert，则此项是必需的。"
          },
          "edit_mode": {
            "type": "string",
            "enum": [
              "replace",
              "insert",
              "delete"
            ],
            "description": "要进行的编辑类型（replace、insert、delete）。默认为 replace。"
          }
        },
        "required": [
          "notebook_path",
          "new_source"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "WebFetch",
      "description": "\n- 从指定 URL 获取内容并使用 AI 模型处理它\n- 将 URL 和提示作为输入\n- 获取 URL 内容，将 HTML 转换为 markdown\n- 使用小型快速模型处理带有提示的内容\n- 返回模型关于内容的响应\n- 当您需要检索和分析网络内容时使用此工具\n\n使用说明：\n  - 重要：如果可用 MCP 提供的网络获取工具，请优先使用该工具而不是此工具，因为它可能具有更少的限制。所有 MCP 提供的工具都以 \"mcp__\" 开头。\n  - URL 必须是完全格式化的有效 URL\n  - HTTP URL 将自动升级为 HTTPS\n  - 提示应描述您想从页面中提取的信息\n  - 此工具是只读的，不会修改任何文件\n  - 如果内容非常大，结果可能会被总结\n  - 包含一个自清理的 15 分钟缓存，以便在重复访问同一 URL 时获得更快的响应\n  - 当 URL 重定向到不同的主机时，工具将通知您并以特殊格式提供重定向 URL。然后，您应该使用重定向 URL 发出新的 WebFetch 请求以获取内容。\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "uri",
            "description": "要从中获取内容的 URL"
          },
          "prompt": {
            "type": "string",
            "description": "要在获取的内容上运行的提示"
          }
        },
        "required": [
          "url",
          "prompt"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "TodoWrite",
      "description": "使用此工具为您当前的编码会话创建和管理结构化任务列表。这可以帮助您跟踪进度、组织复杂任务并向用户展示彻底性。\n它还帮助用户了解任务的进度和他们请求的整体进度。\n\n## 何时使用此工具\n在这些场景中主动使用此工具：\n\n1. 复杂的多步骤任务 - 当任务需要 3 个或更多不同的步骤或操作时\n2. 非平凡和复杂的任务 - 需要仔细规划或多个操作的任务\n3. 用户明确请求待办事项列表 - 当用户直接要求您使用待办事项列表时\n4. 用户提供多个任务 - 当用户提供要完成的事项列表（编号或逗号分隔）时\n5. 收到新指令后 - 立即将用户需求捕获为待办事项\n6. 当您开始处理任务时 - 在开始工作之前将其标记为 in_progress。理想情况下，您一次只应将一个待办事项标记为 in_progress\n7. 完成任务后 - 将其标记为已完成，并添加在实施过程中发现的任何新的后续任务\n\n## 何时不使用此工具\n\n在以下情况下跳过使用此工具：\n1. 只有一个简单的任务\n2. 任务是微不足道的，跟踪它不提供任何组织上的好处\n3. 任务可以在少于 3 个简单步骤中完成\n4. 任务纯粹是对话性或信息性的\n\n请注意，如果只有一个微不足道的任务要做，您不应使用此工具。在这种情况下，您最好直接完成任务。\n\n## 何时使用待办事项列表的示例\n\n<example>\nUser: 我想在应用程序设置中添加一个深色模式切换。完成后确保运行测试和构建！\nAssistant: 我将帮助您在应用程序设置中添加深色模式切换。让我创建一个待办事项列表来跟踪此实现。\n*创建包含以下项目的待办事项列表：*\n1. 在设置页面中创建深色模式切换组件\n2. 添加深色模式状态管理（上下文/存储）\n3. 实现深色主题的 CSS-in-JS 样式\n4. 更新现有组件以支持主题切换\n5. 运行测试和构建过程，解决出现的任何失败或错误\n*开始处理第一个任务*\n\n<reasoning>\n助手使用待办事项列表是因为：\n1. 添加深色模式是一个多步骤功能，需要 UI、状态管理和样式更改\n2. 用户明确要求之后运行测试和构建\n3. 助手通过添加"确保测试和构建成功"作为最终任务推断测试和构建需要通过\n</reasoning>\n</example>\n\n<example>\nUser: 帮我在我的项目中将函数 getCwd 重命名为 getCurrentWorkingDirectory\nAssistant: 让我首先在您的代码库中搜索所有出现的 'getCwd'。\n*使用 grep 或搜索工具在代码库中定位 getCwd 的所有实例*\nAssistant: 我在 8 个不同的文件中找到了 15 个 'getCwd' 实例。让我创建一个待办事项列表来跟踪这些更改。\n*创建包含需要更新的每个文件的具体项目的待办事项列表*\n\n<reasoning>\n助手使用待办事项列表是因为：\n1. 首先，助手搜索以了解任务的范围\n2. 在发现多个文件中的多个实例后，它确定这是一个具有多个步骤的复杂任务\n3. 待办事项列表有助于确保每个实例都被跟踪和系统地更新\n4. 这种方法可以防止遗漏任何实例并保持代码一致性\n</reasoning>\n</example>\n\n\n<example>\nUser: 
我需要为我的电子商务网站实现这些功能：用户注册、产品目录、购物车和结账流程。
Assistant: 我将帮助实现这些功能。首先，让我们将所有功能添加到待办事项列表中。
*根据项目架构创建一个待办事项列表，将每个功能分解为具体任务*
Assistant: 让我们从用户注册开始。这将涉及创建数据库模型、API 端点和与您现有身份验证系统集成的前端表单。

<reasoning>
助手使用待办事项列表是因为：
1. 用户在逗号分隔的列表中提供了多个复杂功能要实现
2. 待办事项列表有助于将这些大型功能组织成可管理的任务
3. 这种方法允许跟踪整个实现的进度
</reasoning>
</example>

<example>
User: 你能帮我优化我的 React 应用程序吗？它的渲染速度很慢，并且存在性能问题。</user>
Assistant: 我将帮助优化您的 React 应用程序。首先，让我检查您的代码库以识别潜在的性能瓶颈。
*审查组件结构、渲染模式、状态管理和数据获取*
Assistant: 在分析您的代码库后，我发现了几个性能问题。让我创建一个待办事项列表来跟踪我们的优化工作。
*创建包含以下项目的待办事项列表：1) 在 ProductList 中为昂贵的计算实现 memoization，2) 在 Dashboard 中为长列表添加虚拟化，3) 优化 Gallery 组件中的图像加载，4) 修复 ShoppingCart 中的状态更新循环，5) 审查包大小并实现代码拆分*
让我们从在 ProductList 组件中为昂贵的计算实现 memoization 开始。</assistant>

<reasoning>
助手使用待办事项列表是因为：
1. 首先，助手检查了代码库以识别具体的性能问题
2. 基于此分析，它识别了多个优化机会
3. 性能优化是一个需要多个步骤的非平凡任务
4. 待办事项列表有助于系统地跟踪不同组件的改进
5. 这种系统化方法确保所有性能瓶颈都得到解决
</reasoning>
</example>

## 何时不使用待办事项列表的示例

<example>
User: 如何在 Python 中打印 'Hello World'？
Assistant: 在 Python 中，您可以使用以下简单代码打印 "Hello World"：

python
print("Hello World")

执行时，这将向控制台输出文本 "Hello World"。</assistant>

<reasoning>
助手没有使用待办事项列表，因为这是一个可以在一个步骤中完成的单一、简单的任务。对于如此直接的请求，无需跟踪多个任务或步骤。
</reasoning>
</example>

<example>
User: git status 命令有什么作用？
Assistant: git status 命令显示工作目录和暂存区的当前状态。它显示哪些更改已暂存、哪些未暂存，以及哪些文件未被 Git 跟踪。这是在进行提交之前了解存储库当前状态的基本命令。

<reasoning>
助手没有使用待办事项列表，因为这是一个信息请求，没有实际的编码任务要完成。用户只是在寻求解释，而不是要求助手执行多个步骤或任务。
</reasoning>
</example>

<example>
User: 你能给 calculateTotal 函数添加一个注释来解释它的作用吗？
Assistant: 当然，让我给 calculateTotal 函数添加一个注释来解释它的作用。
* 使用 Edit 工具向 calculateTotal 函数添加注释 *

<reasoning>
助手没有使用待办事项列表，因为这是一个限于代码中一个位置的单一、直接的任务。添加注释不需要跟踪多个步骤或系统化组织。
</reasoning>
</example>

<example>
User: 为我运行 npm install 并告诉我发生了什么。
Assistant: 我将为您运行 npm install 命令。

*执行：npm install*

命令成功完成。以下是输出：
[npm install 命令的输出]

根据您的 package.json 文件，所有依赖项都已安装。

<reasoning>
助手没有使用待办事项列表，因为这是一个具有即时结果的单个命令执行。没有多个步骤需要跟踪或组织，因此待办事项列表对于这个直接的任务是不必要的。
</reasoning>
</example>

## 任务状态和管理

1. **任务状态**：使用这些状态跟踪进度：
   - pending：任务尚未开始
   - in_progress：当前正在处理（一次限制为一个任务）
   - completed：任务成功完成

2. **任务管理**：
   - 在工作时实时更新任务状态
   - 完成后立即标记任务为完成（不要批量完成）
   - 任何时候只有一个任务处于 in_progress 状态
   - 在开始新任务之前完成当前任务
   - 从列表中完全删除不再相关的任务

3. **任务完成要求**：
   - 仅在您完全完成任务时才将其标记为已完成
   - 如果您遇到错误、阻碍或无法完成，请将任务保持为 in_progress
   - 遇到阻碍时，创建一个新任务描述需要解决的问题
   - 在以下情况下永远不要将任务标记为已完成：
     - 测试失败
     - 实现不完整
     - 您遇到未解决的错误
     - 您找不到必要的文件或依赖项

4. **任务分解**：
   - 创建具体的、可操作的项目
   - 将复杂任务分解为更小、可管理的步骤
   - 使用清晰、描述性的任务名称

如有疑问，请使用此工具。主动进行任务管理可以展示专注性，并确保您成功完成所有要求。\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "todos": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "content": {
                  "type": "string",
                  "minLength": 1
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "pending",
                    "in_progress",
                    "completed"
                  ]
                },
                "id": {
                  "type": "string"
                }
              },
              "required": [
                "content",
                "status",
                "id"
              ],
              "additionalProperties": false
            },
            "description": "更新后的待办事项列表"
          }
        },
        "required": [
          "todos"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "WebSearch",
      "description": "\n- 允许 Claude 搜索网络并使用结果来提供响应\n- 为当前事件和最新数据提供最新信息\n- 返回格式化为搜索结果块的搜索结果信息\n- 使用此工具访问 Claude 知识截止日期之外的信息\n- 在单个 API 调用中自动执行搜索\n\n使用说明：\n  - 支持域过滤以包含或阻止特定网站\n  - 网络搜索仅在美国可用\n  - 在 <env> 中考虑"今天的日期"。例如，如果 <env> 说"今天的日期：2025-07-01"，并且用户想要最新的文档，请不要在搜索查询中使用 2024。使用 2025。\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "minLength": 2,
            "description": "要使用的搜索查询"
          },
          "allowed_domains": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "仅包含来自这些域的搜索结果"
          },
          "blocked_domains": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "永远不要包含来自这些域的搜索结果"
          }
        },
        "required": [
          "query"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "BashOutput",
      "description": "\n- 从正在运行或已完成的后台 bash shell 中检索输出\n- 采用标识 shell 的 shell_id 参数\n- 始终仅返回自上次检查以来的新输出\n- 返回 stdout 和 stderr 输出以及 shell 状态\n- 支持可选的正则表达式过滤以仅显示匹配模式的行\n- 当您需要监控或检查长时间运行的 shell 的输出时使用此工具\n- 可以使用 /bashes 命令找到 Shell ID\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "bash_id": {
            "type": "string",
            "description": "要检索输出的后台 shell 的 ID"
          },
          "filter": {
            "type": "string",
            "description": "可选的正则表达式，用于过滤输出行。只有与此正则表达式匹配的行才会包含在结果中。任何不匹配的行将不再可供读取。"
          }
        },
        "required": [
          "bash_id"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "KillBash",
      "description": "\n- 通过其 ID 终止正在运行的后台 bash shell\n- 采用标识要终止的 shell 的 shell_id 参数\n- 返回成功或失败状态\n- 当您需要终止长时间运行的 shell 时使用此工具\n- 可以使用 /bashes 命令找到 Shell ID\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "shell_id": {
            "type": "string",
            "description": "要终止的后台 shell 的 ID"
          }
        },
        "required": [
          "shell_id"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    }
  ]
}